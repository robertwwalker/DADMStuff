---
title: "Panel Data Summary"
bibliography: "bibliography.bib"
nocite: |
     @*
author: "Robert W. Walker"
format: 
   html:
     self-contained: true
     self-contained-math: true
     code-fold: true
     code-copy: hover
     code-block-border-left: true
     df-print: paged
     embed-resources: true
     fig-format: retina
     footnotes-hover: true
     html-math-method: katex
     mainfont: Playfair Display
     toc: true
     toc-title: Navigation
     theme: simplex
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(message=FALSE, warning=FALSE)
```

# Summarizing Panel Data

A very handy stata command `xtsum` implements a between-within breakdown of two-dimensional space/time data.  This page contains the code to replicate that procedure in R.  

## The basic breakdown

$$y_{it} = \alpha_{\cdot} + X_{it}\beta + \epsilon$$

where 

+ $y_{it}$ is a continuous outcome measure indexed by $i \in N$ units and $t \in T$ time periods.  
+ $\alpha_{\cdot}$ is generic intercept notation that encompasses pooled, one-way, and two-way intercepts.
+ $\beta$ is a vector of pooled slopes.
+ $\epsilon_{it}$ is some i.i.d. disturbance term.

To keep it simple, no creation or destruction of units occurs and every unit is observed at identical discrete points in $T$ that are evenly separated.

Writing a program to do it and generating the output for comparison was the primary goal for writing these two functions.  The process can, itself, be pretty simply recreated by hand to expose the logic.  There is an example dataset to work from among the pins, `eu_balance`.

```{r}
library(tidyverse)
library(plm)
library(pins)
library(DT)
board <- board_url("https://raw.githubusercontent.com/robertwwalker/DADMStuff/master/pins/")
EU.data <- board %>% pin_read("eu_balance")
datatable(EU.data)
```

So I have two index variables, country and year, and two types of balance [current/budget] with values for each.  I want to first reshape the data to separate two distinct variables, current and fiscal.

```{r}
EU.wide <- pivot_wider(EU.data, names_from = account_type, values_from = value)
datatable(EU.wide)
```

Now to the summaries.  There are two implicit datasets to create -- the between [unit means averaged over time] and the within [deviations about the unit mean].  Let's create them; that is group by.

```{r}
( Between.Data <- EU.wide %>% group_by(country) %>% summarise(Current = mean(current, na.rm=TRUE), Fiscal = mean(budget, na.rm=TRUE)) )
```

The data have 19 rows for 19 countries.  The appropriate summary is:

```{r}
library(skimr)
skim(Between.Data)
```

The within data are best thought of using a merge operation.  Let us join the between data back with the original data using the country names.

```{r}
( Complete.Data <- left_join(EU.wide, Between.Data, by = "country") %>% mutate(W.budget = budget - Fiscal, W.current = current - Current) )
```

```{r}
Complete.Data %>% skim(W.current, W.budget)
```

The resulting `within` data are mean zero [by construction], and have 19 degrees of freedom.  The two bits of code that I constructed merely formalize this and use it in a command structure.

Compare this output where the O is overall, the W is within, and B is between.


```{r}
library(tidyverse)
library(plm)
xtsum <- function(formula, data) {
  pform <- terms(formula, data=data)
  unit <- pform[[2]]
  vars <- attr(pform, "term.labels")
  # Add data.frame to strip other attributes.
  data <- data.frame(data)
  # Get classes of the variables
  cls <- sapply(data, class)
  # 8.18.2020 adapted the below line to handle factors and characters by selecting unit
  data <- data %>% select(which(cls %in% c("numeric","integer")),unit)
  # Get the variable names
  varnames <- intersect(names(data),vars)
  # The actual summary function for some variable
  sumfunc <- function(data=data, varname, unit) {
    loc.unit <- enquo(unit)
    varname <- ensym(varname)
    ores <- data %>% filter(!is.na(!! varname)==TRUE) %>% summarise(
      O.mean=round(mean(`$`(data, !! varname), na.rm=TRUE), digits=3),
      O.sd=round(sd(`$`(data, !! varname), na.rm=TRUE), digits=3), 
      O.min = min(`$`(data, !! varname), na.rm=TRUE), 
      O.max=max(`$`(data, !! varname), na.rm=TRUE), 
      O.SumSQ=round(sum(scale(`$`(data, !! varname), center=TRUE, scale=FALSE)^2, na.rm=TRUE), digits=3), 
      O.N=sum(as.numeric((!is.na(`$`(data, !! varname))))))
    bmeans <- data %>% filter(!is.na(!! varname)==TRUE) %>% group_by(!! loc.unit) %>% summarise(
      meanx=mean(`$`(.data, !! varname), na.rm=T), 
      t.count=sum(as.numeric(!is.na(`$`(.data, !! varname)))))
    bres <- bmeans %>% ungroup() %>% summarise(
      B.mean = round(mean(meanx, na.rm=TRUE), digits=3),
      B.sd = round(sd(meanx, na.rm=TRUE), digits=3),
      B.min = min(meanx, na.rm=TRUE), 
      B.max=max(meanx, na.rm=TRUE), 
      B.Units=sum(as.numeric(!is.na(t.count))), 
      B.t.bar=round(mean(t.count, na.rm=TRUE), digits=3))
    wdat <- data %>% filter(!is.na(!! varname)==TRUE) %>% group_by(!! loc.unit) %>% mutate(
      W.x = scale(`$`(.data,!! varname), scale=FALSE))
    wres <- wdat %>% ungroup() %>% summarise(
      W.sd=round(sd(W.x, na.rm=TRUE), digits=3), 
      W.min=min(W.x, na.rm=TRUE), 
      W.max=max(W.x, na.rm=TRUE), 
      W.SumSQ=round(sum(W.x^2, na.rm=TRUE), digits=3))
    W.Ratio <- round(wres$W.SumSQ/ores$O.SumSQ, digits=3)
    return(c(ores,bres,wres,Within.Ovr.Ratio=W.Ratio))
  }
  res1 <- sapply(varnames, function(x) {sumfunc(data, !!x, !!unit)})
  return(data.frame(t(res1)))
}
```

There is an identity that operates.  The overall sum of squares is the between sum of squares plus the within sum of squares.  Taking the example of current, 

+ the overall sum of squares is given as 289119466021.689
+ the within sum of squares is given as 27335114071.846
+ the between sum of squares is the (squared) difference between the unit mean and the overall mean `r sum((Between.Data$Current - mean(Complete.Data$current))^2)` multiplied by 7 time periods [because this difference is time invariant] to yield `r sum((Between.Data$Current - mean(Complete.Data$current))^2)*7`

### Overall

```{r}
sum((Complete.Data$current - mean(Complete.Data$current))^2)
```

### Within

```{r}
sum(Complete.Data$W.current^2)
```

### Between

```{r}
sum((Complete.Data$Current-mean(Complete.Data$current))^2)
```

### Within + Between

```{r}
sum(Complete.Data$W.current^2) + sum((Complete.Data$Current-mean(Complete.Data$current))^2)
```

### Overall [Repeated]

```{r}
sum((Complete.Data$current - mean(Complete.Data$current))^2)
```


```{r, results='asis'}
xtsum(country~., data=EU.wide) %>% datatable()
```

## Description of the commands

Both reproduce the Stata command though one adds a flag for variable types that is automatically undertaken in Stata -- `xtsum`.  For legacy reasons, the AN version that takes all numeric variable types as given.

### xtsum

There are two files.

```
# xtsum.R

library(tidyverse)
library(plm)
xtsum <- function(formula, data) {
  pform <- terms(formula, data=data)
  unit <- pform[[2]]
  vars <- attr(pform, "term.labels")
  # Add data.frame to strip other attributes.
  data <- data.frame(data)
  # Get classes of the variables
  cls <- sapply(data, class)
  # 8.18.2020 adapted the below line to handle factors and characters by selecting unit
  data <- data %>% select(which(cls %in% c("numeric","integer")),unit)
  # Get the variable names
  varnames <- intersect(names(data),vars)
  # The actual summary function for some variable
  sumfunc <- function(data=data, varname, unit) {
    loc.unit <- enquo(unit)
    varname <- ensym(varname)
    ores <- data %>% filter(!is.na(!! varname)==TRUE) %>% summarise(
      O.mean=round(mean(`$`(data, !! varname), na.rm=TRUE), digits=3),
      O.sd=round(sd(`$`(data, !! varname), na.rm=TRUE), digits=3), 
      O.min = min(`$`(data, !! varname), na.rm=TRUE), 
      O.max=max(`$`(data, !! varname), na.rm=TRUE), 
      O.SumSQ=round(sum(scale(`$`(data, !! varname), center=TRUE, scale=FALSE)^2, na.rm=TRUE), digits=3), 
      O.N=sum(as.numeric((!is.na(`$`(data, !! varname))))))
    bmeans <- data %>% filter(!is.na(!! varname)==TRUE) %>% group_by(!! loc.unit) %>% summarise(
      meanx=mean(`$`(.data, !! varname), na.rm=T), 
      t.count=sum(as.numeric(!is.na(`$`(.data, !! varname)))))
    bres <- bmeans %>% ungroup() %>% summarise(
      B.mean = round(mean(meanx, na.rm=TRUE), digits=3),
      B.sd = round(sd(meanx, na.rm=TRUE), digits=3),
      B.min = min(meanx, na.rm=TRUE), 
      B.max=max(meanx, na.rm=TRUE), 
      B.Units=sum(as.numeric(!is.na(t.count))), 
      B.t.bar=round(mean(t.count, na.rm=TRUE), digits=3))
    wdat <- data %>% filter(!is.na(!! varname)==TRUE) %>% group_by(!! loc.unit) %>% mutate(
      W.x = scale(`$`(.data,!! varname), scale=FALSE))
    wres <- wdat %>% ungroup() %>% summarise(
      W.sd=round(sd(W.x, na.rm=TRUE), digits=3), 
      W.min=min(W.x, na.rm=TRUE), 
      W.max=max(W.x, na.rm=TRUE), 
      W.SumSQ=round(sum(W.x^2, na.rm=TRUE), digits=3))
    W.Ratio <- round(wres$W.SumSQ/ores$O.SumSQ, digits=3)
    return(c(ores,bres,wres,Within.Ovr.Ratio=W.Ratio))
  }
  res1 <- sapply(varnames, function(x) {sumfunc(data, !!x, !!unit)})
  return(data.frame(t(res1)))
}
```

### xtsumAN

```
# xtsumAN [AN is all numeric/integer]

xtsumAN <- function(formula, data) {
  pform <- terms(formula, data=data)
  unit <- pform[[2]]
  vars <- attr(pform, "term.labels")
  cls <- sapply(data, class)
  data <- data %>% select(which(cls%in%c("numeric","integer")))
  varnames <- intersect(names(data),vars)
  sumfunc <- function(data=data, varname, unit) {
    loc.unit <- enquo(unit)
    varname <- ensym(varname)
    ores <- data %>% filter(!is.na(!! varname)==TRUE) %>% summarise(
      O.mean=round(mean(`$`(data, !! varname), na.rm=TRUE), digits=3),
      O.sd=round(sd(`$`(data, !! varname), na.rm=TRUE), digits=3), 
      O.min = min(`$`(data, !! varname), na.rm=TRUE), 
      O.max=max(`$`(data, !! varname), na.rm=TRUE), 
      O.SumSQ=round(sum(scale(`$`(data, !! varname), center=TRUE, scale=FALSE)^2, na.rm=TRUE), digits=3), 
      O.N=sum(as.numeric((!is.na(`$`(data, !! varname))))))
    bmeans <- data %>% filter(!is.na(!! varname)==TRUE) %>% group_by(!! loc.unit) %>% summarise(
      meanx=mean(`$`(.data, !! varname), na.rm=T), 
      t.count=sum(as.numeric(!is.na(`$`(.data, !! varname)))))
    bres <- bmeans %>% ungroup() %>% summarise(
      B.mean = round(mean(meanx, na.rm=TRUE), digits=3),
      B.sd = round(sd(meanx, na.rm=TRUE), digits=3),
      B.min = min(meanx, na.rm=TRUE), 
      B.max=max(meanx, na.rm=TRUE), 
      B.Units=sum(as.numeric(!is.na(t.count))), 
      B.t.bar=round(mean(t.count, na.rm=TRUE), digits=3))
    wdat <- data %>% filter(!is.na(!! varname)==TRUE) %>% group_by(!! loc.unit) %>% mutate(
      W.x = scale(`$`(.data,!! varname), scale=FALSE))
    wres <- wdat %>% ungroup() %>% summarise(
      W.sd=round(sd(W.x, na.rm=TRUE), digits=3), 
      W.min=min(W.x, na.rm=TRUE), 
      W.max=max(W.x, na.rm=TRUE), 
      W.SumSQ=round(sum(W.x^2, na.rm=TRUE), digits=3))
    W.Ratio <- round(wres$W.SumSQ/ores$O.SumSQ, digits=3)
    return(c(ores,bres,wres,Within.Ovr.Ratio=W.Ratio))
  }
  res1 <- sapply(varnames, function(x) {sumfunc(data, !!x, !!unit)})
  return(data.frame(t(res1)))
}
```



```{r}
knitr::write_bib(names(sessionInfo()$otherPkgs), file="bibliography.bib")
```